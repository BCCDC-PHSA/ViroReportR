#' fit_epiestim_model - Function to estimate the reproduction number of an epidemic from weekly data
#'
#' @description A wrapper function for {\code{\link[EpiEstim]{estimate_R}}} from the \code{EpiEstim} library to estimate the reproduction number of epidemics to support short-term forecasts
#'
#'
#' @details \code{fit_epiestim_model} currently supports the following epidemics: Influenza, RSV and COVID-19. The serial intervals for the estimation of R were retrieved from
#' Cowling et al., 2011, Vink et al., 2014 and Madewell et al., 2023 for Influenza, RSV and COVID (BA.5 Omicron variant) respectively
#'
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param dt *Integer* 	length of temporal aggregations of the incidence data. This should be an integer or vector of integers. The default value is 7 time units (1 week).
#' @param type *character* Specifies type of epidemic. Must be one of "flu_a", "flu_b", "rsv", "covid" or "other"
#' @param mean_si *Numeric* User specification of mean of parametric serial interval
#' @param std_si *Numeric* User specification of standard deviation of parametric serial interval
#' @param recon_opt One of "naive" or "match" to pass on to {\code{\link[EpiEstim]{estimate_R}}} (see help page)
#' @param method One of "non_parametric_si", "parametric_si", "uncertain_si", "si_from_data" or "si_from_sample" to pass on to {\code{\link[EpiEstim]{estimate_R}}} (see help page)
#' @param ... Other optional parameters to pass on to {\code{\link[EpiEstim]{estimate_R}}} (see help page) to control estimation of reproduction number
#'
#' @import EpiEstim
#' @importFrom magrittr "%>%"
#'
#' @return Object of class {\code{\link[EpiEstim]{estimate_R}}} (see \code{EpiEstim} help page)
#' @export



fit_epiestim_model <- function(data, dt = 7L, type = NULL, mean_si = NULL, std_si = NULL, recon_opt = "match",
                               method = "parametric_si", ...) {
  confirm <- NULL
  if(packageVersion("EpiEstim") == "2.2.4") {
    stop("Please install latest version of EpiEstim from GitHub:
  install.packages('EpiEstim', repos = c('https://mrc-ide.r-universe.dev', 'https://cloud.r-project.org'))")
  }
  if(isFALSE(is.data.frame(data)) | isFALSE(colnames(data) %in% c("date", "confirm")) ) {
    stop("Must pass a data frame with two columns: date and confirm")
  }
  if(missing(type)) {
    stop("Must specify the type of epidemic (flu_a, flu_b, covid, rsv or other)")
  }
  if(isTRUE(type == "other" && isTRUE(is.null(mean_si) & is.null(std_si)))) {
    stop("Must specify mean and standard deviation of parametric serial interval for type other")
  }
  incid <- data$confirm
  if(is.null(mean_si) && is.null(std_si)) {
    if (type == "flu_a" | type == "flu_b") {
      config <- EpiEstim::make_config(list(mean_si = 3.6,
                                 std_si = 1.6))
    } else if (type == "rsv") {
      config <- EpiEstim::make_config(list(mean_si = 7.5,
                                 std_si = 2.1))
    } else if (type == "covid") {
      config <- EpiEstim::make_config(list(mean_si = 2.3,
                                 std_si = 1.4))
    }
  } else {
    config <- EpiEstim::make_config(list(mean_si = mean_si,
                               std_si = std_si))
  }
  a_prior <- (config$mean_prior / config$std_prior)^2
  min_nb_cases_per_time_period <- ceiling(1 / config$cv_posterior^2 - a_prior)

  epiestim_estimates <- NULL
      epiestim_estimates <- suppressWarnings(EpiEstim::estimate_R(incid = incid,
                                                 dt = dt,
                                                 recon_opt = recon_opt,
                                                 method = method,
                                                 config = config, ...))
      if (data$confirm[1] < min_nb_cases_per_time_period) {
        min_reliable_date <- data %>% dplyr::filter(confirm >=  min_nb_cases_per_time_period) %>% dplyr::pull(date)
        warning("Incidence is too low on the current start date. Consider starting R estimation from ", min_reliable_date[1],
                " for an accurate estimate of the reproduction number with EpiEstim")
      }

    return(epiestim_estimates)

}

#' Extract daily forecast samples
#'
#'
#' @description Function to produce short-term daily projections from objects of class {\code{\link[EpiEstim]{estimate_R}}}
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param model_fit Object of class {\code{\link[EpiEstim]{estimate_R}}} generated by running \code{fit_epiestim_model}
#' @param dt *Integer* Number of days aggregated (set to 7 by default for weekly data aggregate)
#' @param n_days 	The number of days to run simulations for. Defaults to 14
#' @param n_sim The number of epicurves to simulate. Defaults to 1000
#'
#'
#'
#' @importFrom magrittr "%>%"
#' @importFrom incidence incidence
#' @importFrom dplyr
#' @importFrom projections project
#' @import utils
#'
#' @return Data-frame of daily forecast samples from all simulations
#' @export
#'

extract_daily_samples_epiestim_fit <- function(data, model_fit, dt = 7L, n_days = 14, n_sim = 1000){
  if(isFALSE(is.data.frame(data)) | isFALSE(colnames(data) %in% c("date", "confirm")) ) {
    stop("Must pass a data frame with two columns: date and confirm")
  }
  confirm <- NULL
  model_data_linelist <-
    tibble::tibble(date = seq(min(data$date),
                      max(data$date) + lubridate::days(dt-1),
                      by = "1 day"),
           confirm = model_fit$I) %>%
    dplyr::group_by(date) %>%
    dplyr::reframe(case_index = seq(1:confirm))

 incidence_obj <- incidence::incidence(model_data_linelist$date)

r_vals <- utils::tail(model_fit$R,n=1)
r_dist <- rtrunc_norm(100, mean = r_vals$`Mean(R)`,sd = r_vals$`Std(R)`, lower_lim = 0)

  # Use the project function
proj <- projections::project(incidence_obj,
                  R = r_dist,
                  si = model_fit$si_distr[-1],
                  n_sim = n_sim,
                  n_days = n_days,
                  R_fix_within = FALSE)


data_proj <- as.data.frame(proj, long = TRUE)

 return (data_proj)
}



#' Iterate through a time-period as a sliding window to produce short-term forecasts with the EpiEstim model fit
#'
#'
#' @description Function to produce short-term forecasts from objects of class {\code{\link[EpiEstim]{estimate_R}}}
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param start_date_str Initial starting time-point. Must match a timepoint in the input dataset
#' @param n_days The number of days to run simulations for. Defaults to 7
#' @param type *character* Specifies type of epidemic. Must be one of "Influenza", "RSV" and "COVID"
#' @param aggregate_week *logical* argument specifying whether to aggregate forecasts by weekly quantiles. Default is to return daily quantiles
#' @param ... Pass on optional arguments from \code{fit_epiestim_model}
#'
#' @importFrom magrittr "%>%"
#' @import lubridate
#'
#'
#' @return List storing quantiles of both daily and 2 week ahead weekly forecasts from each sliding window
#' @export

forecast_time_period_epiestim <- function(data, start_date_str, n_days = 7, aggregate_week = FALSE,
                                            type= NULL, ...) {
  sim <- week_date <- daily_date <- NULL
  if(isFALSE(lubridate::ymd(start_date_str) %in% data$date)) {
    stop("Start date not present in dataset. Please check your input")
  }
  time_length <- nrow(data)-1
  time_period <- seq_len(time_length)
  time_period_result <- lapply(time_period, function(tp) {
    model_data <- extend_rows_model_data(data = data, min_model_date_str = start_date_str,
                                                    extension_interval = tp)
    print(paste0("Current time period: ", tp, " ", "(", max(model_data$date), ")"))
    cur_model <- fit_epiestim_model(model_data, type = type, ...)
   cur_daily_samples <- extract_daily_samples_epiestim_fit(data = model_data, model_fit = cur_model, n_days = n_days)
   cur_daily_samples <- cur_daily_samples %>%
   rename(daily_date = date, daily_sim = sim, daily_value = incidence)

   model_data <- model_data %>%
     dplyr::rename(model_data_date = date)

   if (isTRUE(aggregate_week)) {
     if(isFALSE(n_days %% 7 == 0)) {
       stop("n_days must be a multiple of 7 to aggregate by week")
     }
     cur_samples <- extract_agg_samples_epiestim_fit(cur_daily_samples)
     message("Note: Weekly quantiles were calculated across simulated epicurves")
   cur_samples_agg_quantiles <- cur_samples %>%
    create_quantiles(week_date, variable = "weekly_value") %>%
    dplyr::rename(quantile_date = week_date)
   quantile_unit <- "weekly"
   row <- c(cur_model, tp, model_data, cur_samples, cur_samples_agg_quantiles, quantile_unit = quantile_unit)
   } else {
     message("Note: Daily quantiles were calculated across simulated epicurves")
    cur_samples_agg_quantiles <- cur_daily_samples %>%
       create_quantiles(daily_date, variable = "daily_value") %>%
       dplyr::rename(quantile_date = daily_date)
    quantile_unit <- "daily"
  row <- c(cur_model, tp, model_data, cur_daily_samples, cur_samples_agg_quantiles, quantile_unit = quantile_unit)
   }

   return(row)
  })
  return(time_period_result)

}


#' Extract data-frame with forecasts for violin plot
#'
#' @param time_period_result output from  \code{forecast_time_period_epiestim}
#'
#' @return Data frame with forecasts at all time-points
#' @export
create_forecast_df <- function(time_period_result) {
  results <- lapply(time_period_result, function(i) {
                    pred_samples_with_quantile_helper(tp = i, aggregate_unit =  time_period_result[[1]][["quantile_unit"]])
  })
  results <- do.call(rbind.data.frame, results)
  return(results)
}

#' Plot forecasts at each iteration with uncertainty quantile ranges
#'
#' @param time_period_result output from \code{forecast_time_period_epiestim()}
#'
#' @return Multiple plots with forecasts at each sliding window
#' @export
plot_all_time_period_forecast_data <- function(time_period_result){
  all_times_plots <- lapply(time_period_result, plot_all_time_period_forecast_data_helper)
}
