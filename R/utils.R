#' Extract daily forecast samples
#'
#'
#' @description Function to produce short-term daily projections from objects of class {\code{\link[EpiEstim]{estimate_R}}}
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param model_fit Object of class {\code{\link[EpiEstim]{estimate_R}}} generated by running \code{fit_epiestim_model}
#' @param dt *Integer* Number of days aggregated (set to 7 by default for weekly data aggregate)
#' @param n_days 	The number of days to run simulations for. Defaults to 14
#' @param n_sim The number of epicurves to simulate. Defaults to 1000
#'
#'
#'
#'
#' @return Data-frame of daily forecast samples from all simulations
#' \describe{
#'   \item{date}{date}
#'   \item{incidence}{projected number of daily confirmed cases}
#'   \item{sim}{simulation run number}
#' }

extract_daily_samples_epiestim_fit <- function(data, model_fit, dt = 7L, n_days = 14, n_sim = 1000) {
  if (isFALSE(is.data.frame(data)) | isFALSE(colnames(data) %in% c("date", "confirm"))) {
    stop("Must pass a data frame with two columns: date and confirm")
  }
  confirm <- NULL
  model_data_linelist <-
    tibble::tibble(
      date = seq(min(data$date),
        max(data$date) + lubridate::days(dt - 1),
        by = "1 day"
      ),
      confirm = model_fit$I
    ) %>%
    dplyr::group_by(date) %>%
    dplyr::reframe(case_index = seq(1:confirm))

  incidence_obj <- incidence::incidence(model_data_linelist$date)

  r_vals <- utils::tail(model_fit$R, n = 1)
  r_dist <- rtrunc_norm(100, mean = r_vals$`Mean(R)`, sd = r_vals$`Std(R)`, lower_lim = 0)

  # Use the project function
  proj <- projections::project(incidence_obj,
    R = r_dist,
    si = model_fit$si_distr[-1],
    n_sim = n_sim,
    n_days = n_days,
    R_fix_within = FALSE
  )


  data_proj <- as.data.frame(proj, long = TRUE)

  return(data_proj)
}



#' summarise a data frame `d` by groups along a `variable`
#' @param d tibble data frame
#' @param ... group_by variables
#' @param variable string
#'
#'
#' @return Data frame containing sample quantiles at probabilities 0.05, 0.25, 0.50,
#' 0.75 and 0.95

create_quantiles <- function(d, ..., variable = NULL) {
  d %>%
    dplyr::group_by(...) %>%
    dplyr::summarise(
      p50 = stats::quantile(.data[[variable]], 0.5),
      p25 = stats::quantile(.data[[variable]], 0.25),
      p75 = stats::quantile(.data[[variable]], 0.75),
      p05 = stats::quantile(.data[[variable]], 0.05),
      p95 = stats::quantile(.data[[variable]], 0.95),
      min_sim = min(.data[[variable]]),
      max_sim = max(.data[[variable]])
    )
}

#' Summarise incidence values into weekly aggregate
#' @param samples Daily samples generated from \code{extract_daily_samples_epiestim_fit}
#'
#' @return Data-frame of aggregated weekly forecast samples for each simulation run
#' \describe{
#'   \item{week_date}{last date of week over which daily samples were aggregated}
#'   \item{daily_sim}{simulation run number}
#'   \item{weekly_value}{projected number of daily confirmed cases aggregated by week}
#' }
extract_agg_samples_epiestim_fit <- function(samples) {
  daily_incidence <- week_date <- sim <- daily_date <- NULL
  samples <- samples %>%
    dplyr::mutate(week_date = lubridate::floor_date(daily_date, unit = "weeks")) %>%
    dplyr::group_by(week_date, sim) %>%
    dplyr::summarise(weekly_incidence = sum(daily_incidence), .groups = "keep")

  return(samples)
}


#' extract model data with extension during each iteration of loop
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param min_model_date_str start date (in str)
#' @param extension_interval an integer (# of days)
#'
#'
#' @return input model_data subset to extension interval period specified



extend_rows_model_data <- function(data, min_model_date_str,
                                   extension_interval = 1) {
  min_model_date <- lubridate::ymd(min_model_date_str)

  if (extension_interval > 0) {
    max_model_date <- data$date[which(data$date == min_model_date) + extension_interval]
  }
  model_data <- data %>%
    filter(date >= min_model_date, date <= max_model_date)

  return(model_data)
}



#' Extract calculated quantiles from the weekly samples
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#'


extract_quantile_epiestim <- function(tp) {
  dat_quantiles <-
    tibble::tibble(
      quantile_date = tp$quantile_date,
      p50 = tp$p50,
      p25 = tp$p25,
      p75 = tp$p75,
      p05 = tp$p05,
      p95 = tp$p95,
      min_sim = tp$min_sim,
      max_sim = tp$max_sim
    )
  return(dat_quantiles)
}




# Extract simulated samples

#' Extract simulated samples ideally 1000 samples per date
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#' @param aggregate_unit Time forecasted samples are aggregated by (weekly or daily)
#'



extract_sim_samples_epiestim <- function(tp, aggregate_unit = NULL) {
  if (aggregate_unit == "weekly") {
    dat_samples <- tibble::tibble(
      quantile_date = tp$week_date,
      value = tp$weekly_incidence
    )
  } else if (aggregate_unit == "daily") {
    dat_samples <- tibble::tibble(
      quantile_date = tp$daily_date,
      value = tp$daily_incidence
    )
  }
  return(dat_samples)
}



#' Helper function to plot forecasts at each iteration with uncertainty quantile ranges
#'
#'
#' @param  cur_time_period_result element from list output generated by \code{forecast_time_period_epiestim}
#'
#' @return Plot displaying forecast for one time period

plot_all_time_period_forecast_data_helper <- function(cur_time_period_result) {
  p05 <- p95 <- p25 <- p75 <- p50 <- confirm <- incidence <-  NULL
  model_data <- tibble::tibble(
    date = cur_time_period_result$model_data_date,
    confirm = cur_time_period_result$confirm
  )

  aggregate_unit <- cur_time_period_result$quantile_unit
  if (aggregate_unit == "weekly") {
    data_proj <- tibble::tibble(
      date = cur_time_period_result$week_date,
      sim = cur_time_period_result$sim,
      incidence = cur_time_period_result$weekly_incidence
    )
    p <- data_proj %>%
      dplyr::mutate(incidence = incidence) %>%
      create_quantiles(date, variable = "incidence") %>%
      ggplot2::ggplot(ggplot2::aes(x = date)) +
      ggplot2::theme_bw() +
      ggplot2::geom_ribbon(ggplot2::aes(ymin = p05, ymax = p95), fill = "#08519C", alpha = 0.25) +
      ggplot2::geom_ribbon(ggplot2::aes(ymin = p25, ymax = p75), fill = "#08519C", alpha = 0.25) +
      ggplot2::geom_line(ggplot2::aes(y = p50), color = "#08519C") +
      ggplot2::geom_point(ggplot2::aes(x = date, y = confirm), data = model_data) +
      ggplot2::scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
      ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      ggplot2::labs(
        x = "Time", y = paste("Weekly projection of confirmed \ncases starting from", max(cur_time_period_result$model_data_date), sep = " "),
        fill = "", color = ""
      )
  } else if (aggregate_unit == "daily") {
    data_proj <- tibble::tibble(
      date = cur_time_period_result$daily_date,
      sim = cur_time_period_result$sim,
      incidence = cur_time_period_result$daily_incidence
    )
    p <- data_proj %>%
      dplyr::mutate(incidence = 7 * incidence) %>%
      create_quantiles(date, variable = "incidence") %>%
      ggplot2::ggplot(ggplot2::aes(x = date)) +
      ggplot2::theme_bw() +
      ggplot2::geom_ribbon(ggplot2::aes(ymin = p05, ymax = p95), fill = "#08519C", alpha = 0.25) +
      ggplot2::geom_ribbon(ggplot2::aes(ymin = p25, ymax = p75), fill = "#08519C", alpha = 0.25) +
      ggplot2::geom_line(ggplot2::aes(y = p50), color = "#08519C") +
      ggplot2::geom_point(ggplot2::aes(x = date, y = confirm), data = model_data) +
      ggplot2::scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
      ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      ggplot2::labs(
        x = "Time", y = paste("Weekly projection of confirmed \ncases starting from", max(cur_time_period_result$model_data_date), sep = " "),
        fill = "", color = ""
      )
  }
  return(p)
}


#' Sample from a truncated normal using inverse transform uniform sampling
#'
#'
#' @param  n Number of random samples
#' @param mean Mean of distribution
#' @param sd Standard deviation of distribution
#' @param lower_lim Lower limit for truncation
#'

rtrunc_norm <- function(n, mean = 0, sd = 1, lower_lim = 0) {
  lower_lim <- stats::pnorm(lower_lim, mean = mean, sd = sd)
  samples <- stats::qnorm(stats::runif(n, lower_lim, 1), mean = mean, sd = sd)
  return(samples)
}


#' Helper function to extract dataframe with week ahead forecasts for Violin plot
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#' @param aggregate_unit  Time forecasted samples are aggregated by (weekly or daily)
#'
#'
#' @return Dataframe of forecasts at a single time-point (single element from list input)
#' \describe{
#'   \item{date}{daily date or weekly date over which samples were aggregated}
#'   \item{p50}{median quantile value}
#'   \item{p25}{quantile value of probability 0.25}
#'   \item{p75}{quantile value of probability 0.75}
#'   \item{p05}{quantile value of probability 0.05}
#'   \item{p95}{quantile value of probability 0.95}
#'   \item{pred_horizon}{Prediction time horizon (time period ahead for which prediction was made)}
#'   \item{value}{prediction values from simulated draws}
#' }
#'
pred_samples_with_quantile_helper <- function(tp, aggregate_unit = NULL) {
  value <- quantile_date <- daily_value <- NULL
  cur_samples_with_quantile <- extract_quantile_epiestim(tp)
  seq_time_length <- seq_len(nrow(cur_samples_with_quantile))
  if (aggregate_unit == "weekly") {
    cur_samples_with_quantile$pred_horizon <- paste(seq_time_length, "week ahead")
    cur_samples_with_week_date <- extract_sim_samples_epiestim(tp, aggregate_unit = eval(parse(text = "aggregate_unit")))
    cur_samples_with_quantile <- cur_samples_with_quantile %>%
      dplyr::left_join(cur_samples_with_week_date, by = "quantile_date") %>%
      dplyr::rename(sim_draws = value, weekly_date = quantile_date)
  } else if (aggregate_unit == "daily") {
    cur_samples_with_quantile$pred_horizon <- paste(seq_time_length, "days ahead")
    cur_samples_with_daily_date <- extract_sim_samples_epiestim(tp, aggregate_unit = eval(parse(text = "aggregate_unit")))
    cur_samples_with_quantile <- cur_samples_with_quantile %>%
      dplyr::left_join(cur_samples_with_daily_date, by = "quantile_date") %>%
      dplyr::rename(sim_draws = daily_value, daily_date = quantile_date)
  }

  return(cur_samples_with_quantile)
}


#' Extract data-frame with forecasts for validation violin plot
#'
#' @param time_period_result output from  \code{forecast_time_period_epiestim}
#'
#' @return Data frame with forecasts at all time-points
#' #' \describe{
#'   \item{date}{daily date or weekly date over which samples were aggregated}
#'   \item{p50}{median quantile value}
#'   \item{p25}{quantile value of probability 0.25}
#'   \item{p75}{quantile value of probability 0.75}
#'   \item{p05}{quantile value of probability 0.05}
#'   \item{p95}{quantile value of probability 0.95}
#'   \item{pred_horizon}{Prediction time horizon (time period ahead for which prediction was made)}
#'   \item{value}{prediction values from simulated draws}
#' }
#'

create_forecast_df <- function(time_period_result) {
  results <- lapply(time_period_result, function(i) {
    pred_samples_with_quantile_helper(tp = i, aggregate_unit = time_period_result[[1]][["quantile_unit"]])
  })
  results <- do.call(rbind.data.frame, results)
  return(results)
}


#' Extract combined dataframe with forecast quantiles and weekly case data for summary function
#' @param forecast_dat output from  \code{create_forecast_df}
#' @param data *data frame* containing two columns: date and confirm (number of cases per week)
#' @param pred_horizon_str *string* prediction horizon time period to plot
#' @return combined dataframe with forecast quantiles and weekly case data for summary function
#' #' \describe{
#'   \item{date}{daily date or weekly date over which samples were aggregated}
#'   \item{p50}{median quantile value}
#'   \item{p25}{quantile value of probability 0.25}
#'   \item{p75}{quantile value of probability 0.75}
#'   \item{p05}{quantile value of probability 0.05}
#'   \item{p95}{quantile value of probability 0.95}
#'   \item{pred_horizon}{Prediction time horizon (time period ahead for which prediction was made)}
#'   \item{sim_draws}{prediction values from simulated draws}
#'   \item{min_sim}{minimum value of simulated predictions for week}
#'   \item{max_sim}{maximum value of simulated predictions for week}
#'   \item{confirm}{confirmed weekly cases}
#' }
#'
combine_df_pred_case <- function(forecast_dat, data, pred_horizon_str = NULL) {
  weekly_date <- sim_draws <- NULL
  data <- data %>% dplyr::slice(-c(1, 2))
  future_preds <- as.numeric(substr(pred_horizon_str, 0, 1))
  forecast_dat <- forecast_dat %>%
    dplyr::group_by(weekly_date) %>%
    dplyr::slice(1)
  index_future_pred <- c(rev(seq_len(nrow(forecast_dat)))[1:future_preds])
  forecast_dat <- forecast_dat[-index_future_pred, ]
  return(forecast_dat)
}



