#' summarise a data frame `d` by groups along a `variable`
#' @param d tibble data frame
#' @param ... group_by variables
#' @param variable string
#'
#'  @importFrom magrittr "%>%"
#'  @import dplyr
#'  @importFrom rlang .data
#'
create_quantiles <- function(d, ..., variable = NULL) {
  d %>%
    dplyr::group_by(...) %>%
    dplyr::summarise(
      p50 = stats::quantile(.data[[variable]], 0.5),
      p25 = stats::quantile(.data[[variable]], 0.25),
      p75 = stats::quantile(.data[[variable]], 0.75),
      p05 = stats::quantile(.data[[variable]], 0.05),
      p95 = stats::quantile(.data[[variable]], 0.95)
    )
}

#' Summarise incidence values into weekly aggregate
#' @param samples Daily samples generated from \code{extract_daily_samples_epiestim_fit}
#'
#' @importFrom magrittr "%>%"
#' @import dplyr
#'
extract_agg_samples_epiestim_fit <- function(samples){

  daily_value <- week_date <- daily_sim <- daily_date <- NULL
  samples <- samples %>%
    dplyr::mutate(week_date = lubridate::floor_date(daily_date,unit ="weeks")) %>%
    dplyr::group_by(week_date, daily_sim) %>%
    dplyr::summarise(weekly_value = sum(daily_value), .groups = "keep")

  return (samples)
}



#' Helper function to extract dataframe with week ahead forecasts for Violin plot
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#' @param aggregate_unit  Time forecasted samples are aggregated by (weekly or daily)
#'
#' @importFrom magrittr "%>%"
#'
#' @return Dataframe of 1 week and 2 week forecasts at a single time-point

pred_samples_with_quantile_helper <- function(tp, aggregate_unit = NULL) {
  value <- quantile_date <- daily_value <- NULL
  cur_samples_with_quantile <- extract_quantile_epiestim(tp)
  seq_time_length <- seq_len(nrow(cur_samples_with_quantile))
  if(aggregate_unit == "weekly") {
  cur_samples_with_quantile$pred_horizon <- paste(seq_time_length, "week ahead")
  cur_samples_with_week_date <- extract_sim_samples_epiestim(tp, aggregate_unit = eval(parse(text="aggregate_unit")))
  cur_samples_with_quantile <-  cur_samples_with_quantile %>%
    dplyr::left_join(cur_samples_with_week_date, by = "quantile_date") %>%
    dplyr::rename(sim_draws = value, weekly_date = quantile_date)
  } else if (aggregate_unit == "daily") {
    cur_samples_with_quantile$pred_horizon <- paste(seq_time_length, "days ahead")
    cur_samples_with_daily_date <- extract_sim_samples_epiestim(tp, aggregate_unit = eval(parse(text="aggregate_unit")))
    cur_samples_with_quantile <-  cur_samples_with_quantile %>%
      dplyr::left_join(cur_samples_with_daily_date, by = "quantile_date") %>%
      dplyr::rename(sim_draws = daily_value, daily_date = quantile_date)
  }



  return(cur_samples_with_quantile)

}

#' extract model data with extension during each iteration of loop
#'
#' @param data *data frame* containing two columns: date and confirm (number of cases per day)
#' @param min_model_date_str start date (in str)
#' @param extension_interval an integer (# of days)
#'
#' @importFrom magrittr "%>%"
#' @import dplyr
#' @import lubridate
#'
#' @return model_data with # of days extension specified



extend_rows_model_data <- function(data, min_model_date_str,
                                              extension_interval=1){
  min_model_date <- lubridate::ymd(min_model_date_str)

  if (extension_interval > 0){
    max_model_date <- data$date[which(data$date == min_model_date) + extension_interval]
  }
model_data <- data %>%
    filter(date >= min_model_date, date <= max_model_date)

  return(model_data)
}



#' Extract calculated quantiles from the weekly samples
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#'


extract_quantile_epiestim <- function(tp){
  dat_quantiles <-
    tibble::tibble(quantile_date = tp$quantile_date,
                p50 = tp$p50,
                p25 = tp$p25,
                p75 = tp$p75,
                p05 = tp$p05,
                p95 = tp$p95)
  return(dat_quantiles)
}




# Extract simulated samples

#' Extract simulated samples ideally 1000 samples per date
#'
#' @param tp element from list output generated by \code{forecast_time_period_epiestim}
#' @param aggregate_unit Time forecasted samples are aggregated by (weekly or daily)


extract_sim_samples_epiestim <- function(tp, aggregate_unit = NULL){
  if (aggregate_unit == "weekly") {
  dat_samples <- tibble::tibble(quantile_date = tp$week_date,
                value = tp$weekly_value)
  } else if (aggregate_unit == "daily") {
  dat_samples <- tibble::tibble(quantile_date = tp$daily_date,
                                         value = tp$daily_value)
  }
  return(dat_samples)
}





#' Helper function to plot forecasts at each iteration with uncertainty quantile ranges
#'
#' @import ggplot2
#'
#' @param  cur_time_period_result element from list output generated by \code{forecast_time_period_epiestim}

plot_all_time_period_forecast_data_helper <- function(cur_time_period_result){

    p05 <- p95 <- p25 <- p75 <- p50 <- confirm <- NULL
    model_data <- tibble::tibble(date = cur_time_period_result$model_data_date,
                         confirm = cur_time_period_result$confirm)

    aggregate_unit <- cur_time_period_result$quantile_unit
    if (aggregate_unit == "weekly") {
    data_proj <- tibble::tibble(date = cur_time_period_result$week_date,
                        sim = cur_time_period_result$daily_sim,
                        incidence = cur_time_period_result$weekly_value)
    plot(data_proj %>%
           dplyr::mutate(incidence = incidence) %>%
           create_quantiles(date,variable = "incidence") %>%
           ggplot2::ggplot(aes(x = date)) +
           ggplot2::theme_bw() +
           ggplot2::geom_ribbon(aes(ymin = p05, ymax = p95), fill = "#08519C", alpha = 0.25) +
           ggplot2::geom_ribbon(aes(ymin = p25, ymax = p75), fill = "#08519C", alpha = 0.25) +
           ggplot2::geom_line(aes(y = p50), color = "#08519C") +
           ggplot2::geom_point(aes(x = date, y = confirm), data = model_data) +
           ggplot2::labs(x = "", y = "", fill = "", color = ""))
    } else if (aggregate_unit == "daily") {
    data_proj <- tibble::tibble(date = cur_time_period_result$daily_date,
                                  sim = cur_time_period_result$daily_sim,
                                  incidence = cur_time_period_result$daily_value)
    plot(data_proj %>%
           dplyr::mutate(incidence = 7*incidence) %>%
           create_quantiles(date,variable = "incidence") %>%
           ggplot2::ggplot(aes(x = date)) +
           ggplot2::theme_bw() +
           ggplot2::geom_ribbon(aes(ymin = p05, ymax = p95), fill = "#08519C", alpha = 0.25) +
           ggplot2::geom_ribbon(aes(ymin = p25, ymax = p75), fill = "#08519C", alpha = 0.25) +
           ggplot2::geom_line(aes(y = p50), color = "#08519C") +
           ggplot2::geom_point(aes(x = date, y = confirm), data = model_data) +
           ggplot2::labs(x = "", y = "", fill = "", color = ""))
    }


  }


#' Sample from a truncated normal using inverse transform uniform sampling
#'
#'
#' @param  n Number of random samples
#' @param mean Mean of distribution
#' @param sd Standard deviation of distribution
#' @param lower_lim Lower limit for truncation
#'
#' @importFrom stats pnorm qnorm runif

rtrunc_norm <- function(n, mean, sd, lower_lim = 0) {
  lower_lim <- stats::pnorm(lower_lim, mean = mean, sd = sd)
  samples <- stats::qnorm(stats::runif(n, lower_lim, 1), mean = mean, sd = sd)
  return(samples)
}
